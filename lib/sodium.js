// Generated by IcedCoffeeScript 1.8.0-d
(function() {
  var Base, Sodium, b2u, bufeq_secure, u2b,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  bufeq_secure = require('./util').bufeq_secure;

  Base = require('./base').Base;

  exports.b2u = b2u = function(b) {
    return new Uint8Array(b);
  };

  exports.u2b = u2b = function(u) {
    return new Buffer(u);
  };

  exports.Sodium = Sodium = (function(_super) {
    __extends(Sodium, _super);

    function Sodium() {
      return Sodium.__super__.constructor.apply(this, arguments);
    }

    Sodium.prototype.verify = function(_arg) {
      var code, detached, err, msg, payload, r_payload, sig;
      payload = _arg.payload, sig = _arg.sig, detached = _arg.detached;
      if (detached && (payload == null)) {
        err = new Error("in detached mode, you must supply a payload");
        return [err, null];
      }
      msg = detached ? Buffer.concat([sig, payload]) : sig;
      code = this.lib.c.crypto_sign_open(msg, this.publicKey);
      if (code < 0) {
        err = new Error("Signature failed to verify");
        return [err, null];
      }
      r_payload = sig.slice(this.lib.c.crypto_sign_BYTES);
      if (payload != null) {
        if (!bufeq_secure(r_payload, payload)) {
          err = new Error("got unexpected payload");
          return [err, null];
        }
      } else {
        payload = r_payload;
      }
      return [err, payload];
    };

    return Sodium;

  })(Base);

}).call(this);
