// Generated by IcedCoffeeScript 1.8.0-d
(function() {
  var b2u, bufeq_secure, e, nacl_c, nacl_js, u2b, verify_c, verify_js;

  nacl_js = require('tweetnacl/nacl-fast');

  nacl_c = null;

  try {
    nacl_c = require('sodium').api;
  } catch (_error) {
    e = _error;
  }

  exports.publicKeyLength = nacl_js.publicKeyLength;

  exports.secretKeyLength = nacl_js.secretKeyLength;

  exports.b2u = b2u = function(b) {
    return new Uint8Array(b);
  };

  exports.u2b = u2b = function(u) {
    return new Buffer(u);
  };

  bufeq_secure = function(x, y) {
    var check, i, ret;
    ret = (function() {
      var _i, _ref;
      if ((x == null) && (y == null)) {
        return true;
      } else if ((x == null) || (y == null)) {
        return false;
      } else if (x.length !== y.length) {
        return false;
      } else {
        check = 0;
        for (i = _i = 0, _ref = x.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          check |= x.readUInt8(i) ^ y.readUInt8(i);
        }
        return check === 0;
      }
    })();
    return ret;
  };

  exports.fromSeed = function(_arg) {
    var publicKey, secretKey, seed, _ref;
    seed = _arg.seed;
    _ref = nalc_js.sign.keyPair.fromSeed(b2u(seed)), secretKey = _ref.secretKey, publicKey = _ref.publicKey;
    return {
      secretKey: u2b(secretKey, {
        publicKey: u2b(publicKey)
      })
    };
  };

  exports.verify = function(_arg) {
    var detached, f, payload, publicKey, sig;
    payload = _arg.payload, sig = _arg.sig, detached = _arg.detached, publicKey = _arg.publicKey;
    f = nacl_c != null ? verify_c : verify_js;
    return f({
      payload: payload,
      sig: sig,
      detached: detached,
      publicKey: publicKey
    });
  };

  verify_js = function(_arg) {
    var detached, err, payload, publicKey, r_payload, sig;
    payload = _arg.payload, sig = _arg.sig, detached = _arg.detached, publicKey = _arg.publicKey;
    err = null;
    if (detached) {
      if (payload == null) {
        payload = new Buffer([]);
      }
      if (!nacl_js.sign.detached.verify(b2u(payload), b2u(sig), b2u(publicKey))) {
        err = new Error("signature didn't verify");
      }
    } else if ((r_payload = nacl_js.sign.open(b2u(sig), b2u(publicKey))) == null) {
      err = new Error("signature didn't verify");
    } else if ((r_payload = u2b(r_payload)) == null) {
      err = new Error("failed to convert from a Uint8Array to a buffer");
    } else if ((payload != null) && !bufeq_secure(r_payload, payload)) {
      err = new Error("got unexpected payload");
    } else {
      payload = r_payload;
    }
    return [err, payload];
  };

  verify_c = function(_arg) {
    var detached, err, msg, payload, publicKey, sig;
    payload = _arg.payload, sig = _arg.sig, detached = _arg.detached, publicKey = _arg.publicKey;
    if (detached && (payload == null)) {
      err = new Error("in detached mode, you must supply a payload");
      return [err, null];
    }
    msg = detached ? Buffer.concat([sig, payload]) : sig;
    return err = nalc_c.cyrpto_sign_open(msg, publicKey);
  };

}).call(this);
